/*
 * Convert between temperature and EMF (electromotive force) of
 * thermocouple (Type T) based on ITS-90 Thermocouple Database:
 * https://srdata.nist.gov/its90/main/
 *
 * This is an auto-generated file.
 * (created by: nistcoeff.pl all.tab)
 *
 * !!! DO NOT EDIT THIS FILE. !!!
 *
 */

#include <math.h>
#include "nist-its90.h"

static FLOAT refcoeff_T1[] = {
  0.000000000000E+00,
  0.387481063640E-01,
  0.441944343470E-04,
  0.118443231050E-06,
  0.200329735540E-07,
  0.901380195590E-09,
  0.226511565930E-10,
  0.360711542050E-12,
  0.384939398830E-14,
  0.282135219250E-16,
  0.142515947790E-18,
  0.487686622860E-21,
  0.107955392700E-23,
  0.139450270620E-26,
  0.797951539270E-30
};

static FLOAT refcoeff_T2[] = {
  0.000000000000E+00,
  0.387481063640E-01,
  0.332922278800E-04,
  0.206182434040E-06,
  -0.218822568460E-08,
  0.109968809280E-10,
  -0.308157587720E-13,
  0.454791352900E-16,
  -0.275129016730E-19
};

static FLOAT invcoeff_T1[] = {
  0.0000000E+00,
  2.5949192E+01,
  -2.1316967E-01,
  7.9018692E-01,
  4.2527777E-01,
  1.3304473E-01,
  2.0241446E-02,
  1.2668171E-03
};

static FLOAT invcoeff_T2[] = {
  0.000000E+00,
  2.592800E+01,
  -7.602961E-01,
  4.637791E-02,
  -2.165394E-03,
  6.048144E-05,
  -7.293422E-07,
  0.000000E+00
};

/*
 * calculates emf (thermocouple electromotive force) from temperature.
 * The argument is the temperature in °C.
 * This function returns emf in mV or NAN if the given argument is out of range.
 */
FLOAT
temp2emf_T(FLOAT T)
{
  FLOAT *coeff;
  FLOAT cor = 0;
  int size;

  if (T < -270.000) {
    return NAN;
  } else if (T <= 0.000) {
    coeff = refcoeff_T1;
    size = sizeof(refcoeff_T1) / sizeof(refcoeff_T1[0]);
  } else if (T <= 400.000) {
    coeff = refcoeff_T2;
    size = sizeof(refcoeff_T2) / sizeof(refcoeff_T2[0]);
  } else {
    return NAN;
  }

  cor += polynomial(T, coeff, size);
  return cor;
}

/*
 * calculates temperature from emf (thermocouple electromotive force).
 * The argument is the emf in mV.
 * This function returns a temperature in °C or NAN if the given argument is out of range.
 */
FLOAT
emf2temp_T(FLOAT U)
{
  FLOAT *coeff;
  int size;

  if (U < -5.603) {
    return NAN;
  } else if (U <= 0.000) {
    coeff = invcoeff_T1;
    size = sizeof(invcoeff_T1) / sizeof(invcoeff_T1[0]);
  } else if (U <= 20.872) {
    coeff = invcoeff_T2;
    size = sizeof(invcoeff_T2) / sizeof(invcoeff_T2[0]);
  } else {
    return NAN;
  }

  return polynomial(U, coeff, size);
}

#ifdef TEST
#include <stdio.h>

int
main(int argc, char *argv[])
{
  int T;
  int error = 0;

  if ((argc > 1) && (argv[1][0] == '-') && (argv[1][1] == 'c')) {
    /* output table of values */
    for (T = -270; T <= 400; T++) {
      printf("%d %f\n", T, temp2emf_T((FLOAT)T));
    }
  } else {
    /* check if emf2temp(temp2emf(T)) = T */
    FLOAT torelance = 0.1;
    for (T = -200; T < 400; T++) {
      FLOAT t = emf2temp_T(temp2emf_T((FLOAT)T));
      if (fabs(t - T) > torelance) {
        error = 1;
	fprintf(stderr, "Error: T = %d != %f = emf2temp_T(temp2emf_T(T))\n", T, t);
      }
    }
  }

  return error;
}
#endif
