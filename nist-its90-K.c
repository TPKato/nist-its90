/*
 * Convert between temperature and EMF (electromotive force) of
 * thermocouple (Type K) based on ITS-90 Thermocouple Database:
 * https://srdata.nist.gov/its90/main/
 *
 * This is an auto-generated file.
 * (created by: nistcoeff.pl all.tab)
 *
 * !!! DO NOT EDIT THIS FILE. !!!
 *
 */

#include <math.h>
#include "nist-its90.h"

static FLOAT refcoeff_K1[] = {
  0.000000000000E+00,
  0.394501280250E-01,
  0.236223735980E-04,
  -0.328589067840E-06,
  -0.499048287770E-08,
  -0.675090591730E-10,
  -0.574103274280E-12,
  -0.310888728940E-14,
  -0.104516093650E-16,
  -0.198892668780E-19,
  -0.163226974860E-22
};

static FLOAT refcoeff_K2[] = {
  -0.176004136860E-01,
  0.389212049750E-01,
  0.185587700320E-04,
  -0.994575928740E-07,
  0.318409457190E-09,
  -0.560728448890E-12,
  0.560750590590E-15,
  -0.320207200030E-18,
  0.971511471520E-22,
  -0.121047212750E-25
};

static FLOAT refcoeff_exp_K2[] = {
  0.118597600000E+00,
  -0.118343200000E-03,
  0.126968600000E+03
};

static FLOAT invcoeff_K1[] = {
  0.0000000E+00,
  2.5173462E+01,
  -1.1662878E+00,
  -1.0833638E+00,
  -8.9773540E-01,
  -3.7342377E-01,
  -8.6632643E-02,
  -1.0450598E-02,
  -5.1920577E-04,
  0.0000000E+00
};

static FLOAT invcoeff_K2[] = {
  0.000000E+00,
  2.508355E+01,
  7.860106E-02,
  -2.503131E-01,
  8.315270E-02,
  -1.228034E-02,
  9.804036E-04,
  -4.413030E-05,
  1.057734E-06,
  -1.052755E-08
};

static FLOAT invcoeff_K3[] = {
  -1.318058E+02,
  4.830222E+01,
  -1.646031E+00,
  5.464731E-02,
  -9.650715E-04,
  8.802193E-06,
  -3.110810E-08,
  0.000000E+00,
  0.000000E+00,
  0.000000E+00
};

/*
 * calculates emf (thermocouple electromotive force) from temperature.
 * The argument is the temperature in °C.
 * This function returns emf in mV or NAN if the given argument is out of range.
 */
FLOAT
temp2emf_K(FLOAT T)
{
  FLOAT *coeff;
  FLOAT cor = 0;
  int size;

  if (T < -270.000) {
    return NAN;
  } else if (T <= 0.000) {
    coeff = refcoeff_K1;
    size = sizeof(refcoeff_K1) / sizeof(refcoeff_K1[0]);
  } else if (T <= 1372.000) {
    coeff = refcoeff_K2;
    size = sizeof(refcoeff_K2) / sizeof(refcoeff_K2[0]);
    cor = refcoeff_exp_K2[0] * exp(refcoeff_exp_K2[1] * (T - refcoeff_exp_K2[2]) * (T - refcoeff_exp_K2[2]));
  } else {
    return NAN;
  }

  cor += polynomial(T, coeff, size);
  return cor;
}

/*
 * calculates temperature from emf (thermocouple electromotive force).
 * The argument is the emf in mV.
 * This function returns a temperature in °C or NAN if the given argument is out of range.
 */
FLOAT
emf2temp_K(FLOAT U)
{
  FLOAT *coeff;
  int size;

  if (U < -5.891) {
    return NAN;
  } else if (U <= 0.000) {
    coeff = invcoeff_K1;
    size = sizeof(invcoeff_K1) / sizeof(invcoeff_K1[0]);
  } else if (U <= 20.644) {
    coeff = invcoeff_K2;
    size = sizeof(invcoeff_K2) / sizeof(invcoeff_K2[0]);
  } else if (U <= 54.886) {
    coeff = invcoeff_K3;
    size = sizeof(invcoeff_K3) / sizeof(invcoeff_K3[0]);
  } else {
    return NAN;
  }

  return polynomial(U, coeff, size);
}

#ifdef TEST
#include <stdio.h>

int
main(int argc, char *argv[])
{
  int T;
  int error = 0;

  if ((argc > 1) && (argv[1][0] == '-') && (argv[1][1] == 'c')) {
    /* output table of values */
    for (T = -270; T <= 1372; T++) {
      printf("%d %f\n", T, temp2emf_K((FLOAT)T));
    }
  } else {
    /* check if emf2temp(temp2emf(T)) = T */
    FLOAT torelance = 0.1;
    for (T = -200; T < 1372; T++) {
      FLOAT t = emf2temp_K(temp2emf_K((FLOAT)T));
      if (fabs(t - T) > torelance) {
        error = 1;
	fprintf(stderr, "Error: T = %d != %f = emf2temp_K(temp2emf_K(T))\n", T, t);
      }
    }
  }

  return error;
}
#endif
