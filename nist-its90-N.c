/*
 * Convert between temperature and EMF (electromotive force) of
 * thermocouple (Type N) based on ITS-90 Thermocouple Database:
 * https://srdata.nist.gov/its90/main/
 *
 * This is an auto-generated file.
 * (created by: nistcoeff.pl all.tab)
 *
 * !!! DO NOT EDIT THIS FILE. !!!
 *
 */

#include <math.h>
#include "nist-its90.h"

static FLOAT refcoeff_N1[] = {
  0.000000000000E+00,
  0.261591059620E-01,
  0.109574842280E-04,
  -0.938411115540E-07,
  -0.464120397590E-10,
  -0.263033577160E-11,
  -0.226534380030E-13,
  -0.760893007910E-16,
  -0.934196678350E-19
};

static FLOAT refcoeff_N2[] = {
  0.000000000000E+00,
  0.259293946010E-01,
  0.157101418800E-04,
  0.438256272370E-07,
  -0.252611697940E-09,
  0.643118193390E-12,
  -0.100634715190E-14,
  0.997453389920E-18,
  -0.608632456070E-21,
  0.208492293390E-24,
  -0.306821961510E-28
};

static FLOAT invcoeff_N1[] = {
  0.0000000E+00,
  3.8436847E+01,
  1.1010485E+00,
  5.2229312E+00,
  7.2060525E+00,
  5.8488586E+00,
  2.7754916E+00,
  7.7075166E-01,
  1.1582665E-01,
  7.3138868E-03
};

static FLOAT invcoeff_N2[] = {
  0.00000E+00,
  3.86896E+01,
  -1.08267E+00,
  4.70205E-02,
  -2.12169E-06,
  -1.17272E-04,
  5.39280E-06,
  -7.98156E-08,
  0.00000E+00,
  0.00000E+00
};

static FLOAT invcoeff_N3[] = {
  1.972485E+01,
  3.300943E+01,
  -3.915159E-01,
  9.855391E-03,
  -1.274371E-04,
  7.767022E-07,
  0.000000E+00,
  0.000000E+00,
  0.000000E+00,
  0.000000E+00
};

/*
 * calculates emf (thermocouple electromotive force) from temperature.
 * The argument is the temperature in °C.
 * This function returns emf in mV or NAN if the given argument is out of range.
 */
FLOAT
temp2emf_N(FLOAT T)
{
  FLOAT *coeff;
  FLOAT cor = 0;
  int size;

  if (T < -270.000) {
    return NAN;
  } else if (T <= 0.000) {
    coeff = refcoeff_N1;
    size = sizeof(refcoeff_N1) / sizeof(refcoeff_N1[0]);
  } else if (T <= 1300.000) {
    coeff = refcoeff_N2;
    size = sizeof(refcoeff_N2) / sizeof(refcoeff_N2[0]);
  } else {
    return NAN;
  }

  cor += polynomial(T, coeff, size);
  return cor;
}

/*
 * calculates temperature from emf (thermocouple electromotive force).
 * The argument is the emf in mV.
 * This function returns a temperature in °C or NAN if the given argument is out of range.
 */
FLOAT
emf2temp_N(FLOAT U)
{
  FLOAT *coeff;
  int size;

  if (U < -3.990) {
    return NAN;
  } else if (U <= 0.000) {
    coeff = invcoeff_N1;
    size = sizeof(invcoeff_N1) / sizeof(invcoeff_N1[0]);
  } else if (U <= 20.613) {
    coeff = invcoeff_N2;
    size = sizeof(invcoeff_N2) / sizeof(invcoeff_N2[0]);
  } else if (U <= 47.513) {
    coeff = invcoeff_N3;
    size = sizeof(invcoeff_N3) / sizeof(invcoeff_N3[0]);
  } else {
    return NAN;
  }

  return polynomial(U, coeff, size);
}

#ifdef TEST
#include <stdio.h>

int
main(int argc, char *argv[])
{
  int T;
  int error = 0;

  if ((argc > 1) && (argv[1][0] == '-') && (argv[1][1] == 'c')) {
    /* output table of values */
    for (T = -270; T <= 1300; T++) {
      printf("%d %f\n", T, temp2emf_N((FLOAT)T));
    }
  } else {
    /* check if emf2temp(temp2emf(T)) = T */
    FLOAT torelance = 0.1;
    for (T = -200; T < 1300; T++) {
      FLOAT t = emf2temp_N(temp2emf_N((FLOAT)T));
      if (fabs(t - T) > torelance) {
        error = 1;
	fprintf(stderr, "Error: T = %d != %f = emf2temp_N(temp2emf_N(T))\n", T, t);
      }
    }
  }

  return error;
}
#endif
