#!/usr/bin/perl

# Note: This program assumes that units of temperature and emf are
#       degree-Celsius and mV respectively.

use strict;

my $basename = "nist-its90";
my $command = "$0 " . join(" ", @ARGV);

my %data;
my $type;

# .h (header file for C)
open(HEADER, ">$basename.h") || die "$basename.h: $!";
print HEADER <<"DOT_H_HEAD";
/*
 * Convert between temperature and EMF (electromotive force) of
 * thermocouples based on ITS-90 Thermocouple Database:
 * https://srdata.nist.gov/its90/main/
 *
 * This is an auto-generated file.
 * (created by: $command)
 *
 * !!! DO NOT EDIT THIS FILE. !!!
 *
*/

#ifndef __NIST_ITS90_H__
#define __NIST_ITS90_H__

#include "nist-its90-config.h"

#ifdef NIST_ITS90_USE_DOUBLE
typedef double FLOAT;
#else
typedef float FLOAT;
#endif

#ifdef __cplusplus
extern "C" {
#endif

FLOAT polynomial(FLOAT x, FLOAT *coeff, int size);

DOT_H_HEAD

while (<>) {
    my $type;
    my $arefdata;

    if (/^name: reference function on ITS-90/) {
	# new section starts
	my ($type, $aref_refdata, $aref_invdata) = readCoeff();
	writeProg_C($type, $aref_refdata, $aref_invdata);
	writeProg_H($type, $aref_refdata, $aref_invdata);
    }
}

print HEADER <<"DOT_H_FOOT";
#ifdef __cplusplus
}
#endif

#endif /* __NIST_ITS90_H__ */
DOT_H_FOOT

close(HEADER);

# ============================================================
sub readCoeff {
    my @refdata;
    my @invdata;
    my $type;

    # ------------------------------------------------------------
    # read coefficients of reference function (temperature -> emf)
    my $n = -1;
    my $expmode = 0;
    while (<>) {
	s/[\r\n]+$//;
	s/^\s+//; s/\s+$//;

	if (/^range:\s*(\S.*)$/) {
	    $expmode = 0;
	    $n++;
	    $refdata[$n] = {};

	    my (@t) = split(/,\s*/, $1);
	    $refdata[$n]{Tfrom} = $t[0];
	    $refdata[$n]{Tto} = $t[1];
	    $refdata[$n]{coeff} = [];
	} elsif (/^-?\d+/) {
	    push(@{$refdata[$n]{coeff}}, $_);
	} elsif (/^type: (.*)$/) {
	    $type = $1;
	} elsif (/^exponential:/) {
	    $expmode = 1;
	    $refdata[$n]{exp} = [];
	} elsif (/^a\d*\s*=\s*([-\d].*)$/) {
	    die "something wrong (exponential coefficients)" unless $expmode;
	    push(@{$refdata[$n]{exp}}, $1);
	} elsif (/^\*+/) {
	    last;
	} else {
	    # do nothing
	}
    }

    # ------------------------------------------------------------
    # wait for the section of inverse function
    while (<>) {
	if (/Inverse coefficients for type (.):/) {
	    if ($type ne $1) {
		die "something wrong (type is not identical)"
	    }
	    last;
	}
    }

    # ------------------------------------------------------------
    # read coefficients of inverse function (emf -> temperature)
    while (<>) {
	s/[\r\n]+$//;
	s/^\s+//; s/\s+$//;

	if (/^Temperature\s+(\S.*)$/i) {
	    # temperature range (from)
	    my $n = 0;

	    foreach my $i (split(/\s+/, $1)) {
		$invdata[$n] = { "Tfrom" => $i };
		$invdata[$n]{coeff} = [];
		$n++;
	    }

	    # read temperature range (to)
	    $n = 0;
	    $_ = <>;
	    s/[\r\n]+$//;
	    s/^\s+//; s/\s+$//;
	    if (! /Range:\s*(\S.*)$/i) {
		die "something wrong";
	    }
	    foreach my $i (split(/\s+/, $1)) {
		$invdata[$n]{Tto} = $i;
		$n++;
	    }
	} elsif (/^Voltage\s+(\S.*)$/i) {
	    # voltage range (from)
	    my $n = 0;
	    foreach my $i (split(/\s+/, $1)) {
		$invdata[$n]{Ufrom} = $i;
		$n++;
	    }

	    # read voltage range (to)
	    $n = 0;
	    $_ = <>;
	    s/[\r\n]+$//;
	    s/^\s+//; s/\s+$//;
	    if (! /Range:\s*(\S.*)$/i) {
		die "something wrong";
	    }
	    foreach my $i (split(/\s+/, $1)) {
		$invdata[$n]{Uto} = $i;
		$n++;
	    }
	} elsif (/^Error\s+(\S.*)$/i) {
	    # error range (from)
	    my $n = 0;
	    foreach my $i (split(/\s+/, $1)) {
		$invdata[$n]{Efrom} = $i;
		$n++;
	    }

	    # read error range (to)
	    $n = 0;
	    $_ = <>;
	    s/[\r\n]+$//;
	    s/^\s+//; s/\s+$//;
	    if (! /Range:\s*(\S.*)$/i) {
		die "something wrong";
	    }
	    foreach my $i (split(/\s+/, $1)) {
		$invdata[$n]{Eto} = $i;
		$n++;
	    }
	    last;
	} elsif (/^-?\d+/) {
	    my $n = 0;
	    foreach my $i (split(/\s+/)) {
		push(@{$invdata[$n]{coeff}}, $i);
		$n++;
	    }
	} elsif (/^\*+/ || eof()) {
	    last;
	}
    }

    return ($type, \@refdata, \@invdata);
}

sub writeProg_C {
    my ($type, $aref_refdata, $aref_invdata) = @_;
    my $n;

    my $outfilename = "nist-its90-$type.c";
    open(FILE, ">$outfilename") || die "$outfilename: $!";

    # ------------------------------------------------------------
    print FILE <<"EOHEAD";
/*
 * Convert between temperature and EMF (electromotive force) of
 * thermocouple (Type $type) based on ITS-90 Thermocouple Database:
 * https://srdata.nist.gov/its90/main/
 *
 * This is an auto-generated file.
 * (created by: $command)
 *
 * !!! DO NOT EDIT THIS FILE. !!!
 *
 */

#include <math.h>
#include "nist-its90.h"

EOHEAD

    # ------------------------------------------------------------
    # print coefficients of reference function
    $n = 1;
    foreach my $i (@{$aref_refdata}) {
	print FILE "static FLOAT refcoeff_$type${n}[] = {\n";
	print FILE "  ";
	print FILE join(",\n  ", @{${$i}{coeff}}) . "\n";
	print FILE "};\n";
	print FILE "\n";

	if (${$i}{exp}) {
	    print FILE "static FLOAT refcoeff_exp_$type${n}[] = {\n";
	    print FILE "  ";
	    print FILE join(",\n  ", @{${$i}{exp}}) . "\n";
	    print FILE "};\n";
	    print FILE "\n";
	}

	$n++;
    }

    # ------------------------------------------------------------
    # print coefficients of inverse function
    $n = 1;
    foreach my $i (@{$aref_invdata}) {
	print FILE "static FLOAT invcoeff_$type${n}[] = {\n";
	print FILE "  ";
	print FILE join(",\n  ", @{${$i}{coeff}}) . "\n";
	print FILE "};\n";
	print FILE "\n";
	$n++;
    }

    # ------------------------------------------------------------
    # write temp2emf()
    my $tmin = ${$aref_refdata}[0]{Tfrom};
    my $tmax;

    print FILE <<"EOT2E";
/*
 * calculates emf (thermocouple electromotive force) from temperature.
 * The argument is the temperature in °C.
 * This function returns emf in mV or NAN if the given argument is out of range.
 */
FLOAT
temp2emf_$type(FLOAT T)
{
  FLOAT *coeff;
  FLOAT cor = 0;
  int size;

  if (T < $tmin) {
    return NAN;
EOT2E

    my $n = 1;
    foreach my $i (@{$aref_refdata}) {
	my $c = "refcoeff_$type$n";
	print FILE "  } else if (T <= " . ${$i}{Tto} . ") {\n";
	print FILE "    coeff = $c;\n";
	print FILE "    size = sizeof($c) / sizeof(${c}[0]);\n";

	if (${$i}{exp}) {
	    my $cexp = "refcoeff_exp_$type${n}";
	    print FILE "    cor = ${cexp}[0] * exp(${cexp}[1] * (T - ${cexp}[2]) * (T - ${cexp}[2]));\n";
	}

	$tmax = ${$i}{Tto};
	$n++;
    }
    print FILE <<"EOT2E2";
  } else {
    return NAN;
  }

  cor += polynomial(T, coeff, size);
  return cor;
}

EOT2E2

    # ------------------------------------------------------------
    # write emf2temp()
    my $umin = ${$aref_invdata}[0]{Ufrom};
    my $tinvmin = ${$aref_invdata}[0]{Tfrom};
    my $tinvmax;

    print FILE <<"EOE2T";
/*
 * calculates temperature from emf (thermocouple electromotive force).
 * The argument is the emf in mV.
 * This function returns a temperature in °C or NAN if the given argument is out of range.
 */
FLOAT
emf2temp_$type(FLOAT U)
{
  FLOAT *coeff;
  int size;

  if (U < $umin) {
    return NAN;
EOE2T

    $n = 1;
    foreach my $i (@{$aref_invdata}) {
	my $c = "invcoeff_$type$n";
	print FILE "  } else if (U <= " . ${$i}{Uto} . ") {\n";
	print FILE "    coeff = $c;\n";
	print FILE "    size = sizeof($c) / sizeof(${c}[0]);\n";

	$tinvmax = ${$i}{Tto};
	$n++;
    }
    print FILE <<"EOT2E2";
  } else {
    return NAN;
  }

  return polynomial(U, coeff, size);
}
EOT2E2

    # ------------------------------------------------------------
    # test program
    my $tl = int(($tmin > $tinvmin) ? $tmin : $tinvmin);
    my $tu = int(($tmax < $tinvmax) ? $tmax : $tinvmax);
    $tmin = int($tmin);
    $tmax = int($tmax);

    print FILE <<"EOTEST";

#ifdef TEST
#include <stdio.h>

int
main(int argc, char *argv[])
{
  int T;
  int error = 0;

  if ((argc > 1) && (argv[1][0] == '-') && (argv[1][1] == 'c')) {
    /* output table of values */
    for (T = $tmin; T <= $tmax; T++) {
      printf("%d %f\\n", T, temp2emf_$type((FLOAT)T));
    }
  } else {
    /* check if emf2temp(temp2emf(T)) = T */
    FLOAT torelance = 0.1;
    for (T = $tl; T < $tu; T++) {
      FLOAT t = emf2temp_$type(temp2emf_$type((FLOAT)T));
      if (fabs(t - T) > torelance) {
        error = 1;
	fprintf(stderr, "Error: T = %d != %f = emf2temp_$type(temp2emf_$type(T))\\n", T, t);
      }
    }
  }

  return error;
}
#endif
EOTEST

    close(FILE);
}

sub writeProg_H {
    my ($type, $aref_refdata, $aref_invdata) = @_;

    print HEADER "FLOAT temp2emf_${type}(FLOAT temperature);\n";
    print HEADER "FLOAT emf2temp_${type}(FLOAT emf);\n";
    print HEADER "\n";
}
