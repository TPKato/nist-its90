/*
 * Convert between temperature and EMF (electromotive force) of
 * thermocouple (Type R) based on ITS-90 Thermocouple Database:
 * https://srdata.nist.gov/its90/main/
 *
 * This is an auto-generated file.
 * (created by: nistcoeff.pl all.tab)
 *
 * !!! DO NOT EDIT THIS FILE. !!!
 *
 */

#include <math.h>
#include "nist-its90.h"

static FLOAT refcoeff_R1[] = {
  0.000000000000E+00,
  0.528961729765E-02,
  0.139166589782E-04,
  -0.238855693017E-07,
  0.356916001063E-10,
  -0.462347666298E-13,
  0.500777441034E-16,
  -0.373105886191E-19,
  0.157716482367E-22,
  -0.281038625251E-26
};

static FLOAT refcoeff_R2[] = {
  0.295157925316E+01,
  -0.252061251332E-02,
  0.159564501865E-04,
  -0.764085947576E-08,
  0.205305291024E-11,
  -0.293359668173E-15
};

static FLOAT refcoeff_R3[] = {
  0.152232118209E+03,
  -0.268819888545E+00,
  0.171280280471E-03,
  -0.345895706453E-07,
  -0.934633971046E-14
};

static FLOAT invcoeff_R1[] = {
  0.0000000E+00,
  1.8891380E+02,
  -9.3835290E+01,
  1.3068619E+02,
  -2.2703580E+02,
  3.5145659E+02,
  -3.8953900E+02,
  2.8239471E+02,
  -1.2607281E+02,
  3.1353611E+01,
  -3.3187769E+00
};

static FLOAT invcoeff_R2[] = {
  1.334584505E+01,
  1.472644573E+02,
  -1.844024844E+01,
  4.031129726E+00,
  -6.249428360E-01,
  6.468412046E-02,
  -4.458750426E-03,
  1.994710149E-04,
  -5.313401790E-06,
  6.481976217E-08,
  0.000000000E+00
};

static FLOAT invcoeff_R3[] = {
  -8.199599416E+01,
  1.553962042E+02,
  -8.342197663E+00,
  4.279433549E-01,
  -1.191577910E-02,
  1.492290091E-04,
  0.000000000E+00,
  0.000000000E+00,
  0.000000000E+00,
  0.000000000E+00,
  0.000000000E+00
};

static FLOAT invcoeff_R4[] = {
  3.406177836E+04,
  -7.023729171E+03,
  5.582903813E+02,
  -1.952394635E+01,
  2.560740231E-01,
  0.000000000E+00,
  0.000000000E+00,
  0.000000000E+00,
  0.000000000E+00,
  0.000000000E+00,
  0.000000000E+00
};

/*
 * calculates emf (thermocouple electromotive force) from temperature.
 * The argument is the temperature in °C.
 * This function returns emf in mV or NAN if the given argument is out of range.
 */
FLOAT
temp2emf_R(FLOAT T)
{
  FLOAT *coeff;
  FLOAT cor = 0;
  int size;

  if (T < -50.000) {
    return NAN;
  } else if (T <= 1064.180) {
    coeff = refcoeff_R1;
    size = sizeof(refcoeff_R1) / sizeof(refcoeff_R1[0]);
  } else if (T <= 1664.500) {
    coeff = refcoeff_R2;
    size = sizeof(refcoeff_R2) / sizeof(refcoeff_R2[0]);
  } else if (T <= 1768.100) {
    coeff = refcoeff_R3;
    size = sizeof(refcoeff_R3) / sizeof(refcoeff_R3[0]);
  } else {
    return NAN;
  }

  cor += polynomial(T, coeff, size);
  return cor;
}

/*
 * calculates temperature from emf (thermocouple electromotive force).
 * The argument is the emf in mV.
 * This function returns a temperature in °C or NAN if the given argument is out of range.
 */
FLOAT
emf2temp_R(FLOAT U)
{
  FLOAT *coeff;
  int size;

  if (U < -0.226) {
    return NAN;
  } else if (U <= 1.923) {
    coeff = invcoeff_R1;
    size = sizeof(invcoeff_R1) / sizeof(invcoeff_R1[0]);
  } else if (U <= 13.228) {
    coeff = invcoeff_R2;
    size = sizeof(invcoeff_R2) / sizeof(invcoeff_R2[0]);
  } else if (U <= 19.739) {
    coeff = invcoeff_R3;
    size = sizeof(invcoeff_R3) / sizeof(invcoeff_R3[0]);
  } else if (U <= 21.103) {
    coeff = invcoeff_R4;
    size = sizeof(invcoeff_R4) / sizeof(invcoeff_R4[0]);
  } else {
    return NAN;
  }

  return polynomial(U, coeff, size);
}

#ifdef TEST
#include <stdio.h>

int
main(int argc, char *argv[])
{
  int T;
  int error = 0;

  if ((argc > 1) && (argv[1][0] == '-') && (argv[1][1] == 'c')) {
    /* output table of values */
    for (T = -50; T <= 1768; T++) {
      printf("%d %f\n", T, temp2emf_R((FLOAT)T));
    }
  } else {
    /* check if emf2temp(temp2emf(T)) = T */
    FLOAT torelance = 0.1;
    for (T = -50; T < 1768; T++) {
      FLOAT t = emf2temp_R(temp2emf_R((FLOAT)T));
      if (fabs(t - T) > torelance) {
        error = 1;
	fprintf(stderr, "Error: T = %d != %f = emf2temp_R(temp2emf_R(T))\n", T, t);
      }
    }
  }

  return error;
}
#endif
