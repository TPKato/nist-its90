/*
 * Convert between temperature and EMF (electromotive force) of
 * thermocouple (Type J) based on ITS-90 Thermocouple Database:
 * https://srdata.nist.gov/its90/main/
 *
 * This is an auto-generated file.
 * (created by: nistcoeff.pl all.tab)
 *
 * !!! DO NOT EDIT THIS FILE. !!!
 *
 */

#include <math.h>
#include "nist-its90.h"

static FLOAT refcoeff_J1[] = {
  0.000000000000E+00,
  0.503811878150E-01,
  0.304758369300E-04,
  -0.856810657200E-07,
  0.132281952950E-09,
  -0.170529583370E-12,
  0.209480906970E-15,
  -0.125383953360E-18,
  0.156317256970E-22
};

static FLOAT refcoeff_J2[] = {
  0.296456256810E+03,
  -0.149761277860E+01,
  0.317871039240E-02,
  -0.318476867010E-05,
  0.157208190040E-08,
  -0.306913690560E-12
};

static FLOAT invcoeff_J1[] = {
  0.0000000E+00,
  1.9528268E+01,
  -1.2286185E+00,
  -1.0752178E+00,
  -5.9086933E-01,
  -1.7256713E-01,
  -2.8131513E-02,
  -2.3963370E-03,
  -8.3823321E-05
};

static FLOAT invcoeff_J2[] = {
  0.000000E+00,
  1.978425E+01,
  -2.001204E-01,
  1.036969E-02,
  -2.549687E-04,
  3.585153E-06,
  -5.344285E-08,
  5.099890E-10,
  0.000000E+00
};

static FLOAT invcoeff_J3[] = {
  -3.11358187E+03,
  3.00543684E+02,
  -9.94773230E+00,
  1.70276630E-01,
  -1.43033468E-03,
  4.73886084E-06,
  0.00000000E+00,
  0.00000000E+00,
  0.00000000E+00
};

/*
 * calculates emf (thermocouple electromotive force) from temperature.
 * The argument is the temperature in °C.
 * This function returns emf in mV or NAN if the given argument is out of range.
 */
FLOAT
temp2emf_J(FLOAT T)
{
  FLOAT *coeff;
  FLOAT cor = 0;
  int size;

  if (T < -210.000) {
    return NAN;
  } else if (T <= 760.000) {
    coeff = refcoeff_J1;
    size = sizeof(refcoeff_J1) / sizeof(refcoeff_J1[0]);
  } else if (T <= 1200.000) {
    coeff = refcoeff_J2;
    size = sizeof(refcoeff_J2) / sizeof(refcoeff_J2[0]);
  } else {
    return NAN;
  }

  cor += polynomial(T, coeff, size);
  return cor;
}

/*
 * calculates temperature from emf (thermocouple electromotive force).
 * The argument is the emf in mV.
 * This function returns a temperature in °C or NAN if the given argument is out of range.
 */
FLOAT
emf2temp_J(FLOAT U)
{
  FLOAT *coeff;
  int size;

  if (U < -8.095) {
    return NAN;
  } else if (U <= 0.000) {
    coeff = invcoeff_J1;
    size = sizeof(invcoeff_J1) / sizeof(invcoeff_J1[0]);
  } else if (U <= 42.919) {
    coeff = invcoeff_J2;
    size = sizeof(invcoeff_J2) / sizeof(invcoeff_J2[0]);
  } else if (U <= 69.553) {
    coeff = invcoeff_J3;
    size = sizeof(invcoeff_J3) / sizeof(invcoeff_J3[0]);
  } else {
    return NAN;
  }

  return polynomial(U, coeff, size);
}

#ifdef TEST
#include <stdio.h>

int
main(int argc, char *argv[])
{
  int T;
  int error = 0;

  if ((argc > 1) && (argv[1][0] == '-') && (argv[1][1] == 'c')) {
    /* output table of values */
    for (T = -210; T <= 1200; T++) {
      printf("%d %f\n", T, temp2emf_J((FLOAT)T));
    }
  } else {
    /* check if emf2temp(temp2emf(T)) = T */
    FLOAT torelance = 0.1;
    for (T = -210; T < 1200; T++) {
      FLOAT t = emf2temp_J(temp2emf_J((FLOAT)T));
      if (fabs(t - T) > torelance) {
        error = 1;
	fprintf(stderr, "Error: T = %d != %f = emf2temp_J(temp2emf_J(T))\n", T, t);
      }
    }
  }

  return error;
}
#endif
